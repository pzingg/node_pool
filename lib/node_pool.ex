defmodule NodePool do
  @moduledoc """
  Load distribution facility.

  This module adds extensions to Erlang's pool module.

  The module can be used to run a set of BEAM nodes as a pool of computational processors.
  It is organized as a master and a set of slave nodes and includes the following features:

  The slave nodes send regular reports to the master about their current load.
  Queries can be sent to the master to determine which node will have the least load.
  The BIF statistics(run_queue) is used for estimating future loads. It returns the length
  of the queue of ready to run processes in the Erlang runtime system.

  The slave nodes are started with the slave(3) module. This effects terminal I/O, file I/O,
  and code loading.

  If the master node fails, the entire pool exits.

  Starting Elixir code was generated by erl2ex (http://github.com/dazuma/erl2ex) from
  Erlang source pool.erl.
  """

  use GenServer

  @elem_node 2
  @server_name ElixirPoolMaster
  @global_tuple {:global, @server_name}

  # ---------------------------------------------------------------------------
  # Public API

  @doc """
  Differing from the Erlang version, the .hosts.erlang file is not consulted.
  Instead, the pool can be started various ways:

    1. Empty. Nodes can be attached to the pool and started after initialization.

    2. With the current node (the "master") by specifying the :include_master
         option.

    3. With a list of already created "slave" nodes.

  The slave nodes are started with slave:start/2,3, passing along the short name
  from each node and, if provided, command-line arguments specified in the :start_args
  option.

  Access rights must be set so that all nodes in the pool have the authority to
  access each other.

  The function is synchronous and all the nodes, and all the system servers, are
  running when it returns a value.

  arg - A Keyword list (new to the Elixir version).
    :slave_nodes - optional list of the long names (atoms) of nodes that will be
      attached (and possibly started) when pool is initialized.
    :include_master - if true, include Node.self() in the pool (default false)
    :no_start - if true, do not attempt to start nodes as they are attached (default false)
    :no_stats - if true, no statistics are collected (useful for tests) (default false)
    :start_args - optional string of command line args for :slave.start_link
    :on_attach - optional {module, func} tuple that specifies a 1-arity function

  These keywords can be used in an Application module, to start this module, like this:

  ```
  children =
    [{NodePool, [slave_nodes: [:"node1@127.0.0.1"], no_start: true]}]
  ```
  """
  def start_link(arg) do
    GenServer.start_link(__MODULE__, arg, name: @global_tuple)
  end

  @spec get_nodes() :: list(node())
  def get_nodes() do
    get_elements(@elem_node, get_nodes_and_load())
  end

  @spec attach(var_node) :: :already_attached | :attached when var_node: node()
  def attach(var_node) do
    GenServer.call(@global_tuple, {:attach, var_node})
  end

  def get_nodes_and_load() do
    GenServer.call(@global_tuple, :get_nodes)
  end

  @doc """
  Returns the node with the expected lowest future load.

  Differing from the Erlang pool, you may specify a list of nodes to
  exclude from the search (for example, the master node).
  """
  @spec get_node([node()]) :: node()
  def get_node(excluding \\ []) do
    GenServer.call(@global_tuple, {:get_node, excluding})
  end

  @spec pspawn(mod, fun, args) :: pid() when mod: module(), fun: atom(), args: list(term())
  def pspawn(m, f, a) do
    GenServer.call(@global_tuple, {:spawn, :erlang.group_leader(), m, f, a})
  end

  @spec pspawn_link(mod, fun, args) :: pid() when mod: module(), fun: atom(), args: list(term())
  def pspawn_link(m, f, a) do
    Node.spawn_link(get_node(), m, f, a)
  end

  @spec stop() :: :stopped
  def stop() do
    GenServer.call(@global_tuple, :stop)
  end

  # ---------------------------------------------------------------------------
  # GenServer callbacks

  @impl true
  def init(arg) do
    Process.flag(:trap_exit, true)

    {slave_nodes, opts} = Keyword.pop(arg, :slave_nodes, [])

    nodes =
      if Keyword.get(opts, :include_master, false) do
        slave_nodes ++ [Node.self()]
      else
        slave_nodes
      end
      |> Enum.uniq()

    case nodes do
      [] ->
        {:ok, {[], opts}}

      _ ->
        {:ok, {[], opts}, {:continue, {:attach, nodes}}}
    end
  end

  @impl true
  def handle_continue({:attach, node_list}, {nodes, opts}) do
    new_nodes = attach_nodes(node_list, nodes, opts)
    {:noreply, {new_nodes, opts}}
  end

  @impl true
  def handle_call(:get_nodes, _from, {nodes, opts}) do
    {:reply, nodes, {nodes, opts}}
  end

  def handle_call({:get_node, excluding}, _from, {nodes, opts}) do
    {value, new_nodes} = pop_node(nodes, excluding)
    {:reply, value, {new_nodes, opts}}
  end

  def handle_call({:attach, var_node}, _from, {nodes, opts}) do
    {value, new_nodes} = attach_node(var_node, nodes, opts)
    {:reply, value, {new_nodes, opts}}
  end

  def handle_call({:spawn, gl, m, f, a}, from, {nodes, opts}) do
    {:reply, node, new_nodes} = handle_call(:get_node, from, nodes)
    pid = Node.spawn(node, __MODULE__, :do_spawn, [gl, m, f, a])
    {:reply, pid, {new_nodes, opts}}
  end

  def handle_call(:stop, _from, state) do
    {:stop, :normal, :stopped, state}
  end

  @doc """
  No API. Used for tests.
  """
  def handle_call(:get_state, _from, state), do: {:reply, state, state}

  @impl true
  def handle_cast(_, state) do
    {:noreply, state}
  end

  @impl true
  def handle_info({var_node, :load, load}, {nodes, opts}) do
    {:noreply, {insert_node({load, var_node}, nodes), opts}}
  end

  def handle_info({:nodedown, var_node}, {nodes, opts}) do
    {:noreply, {:lists.keydelete(var_node, @elem_node, nodes), opts}}
  end

  def handle_info(_, state) do
    {:noreply, state}
  end

  @impl true
  def terminate(_reason, {nodes, _opts}) do
    n = :lists.delete(Node.self(), get_elements(@elem_node, nodes))
    stop_em(n)
    :ok
  end

  # --------------------------------------------------------
  # Private functions

  defp attach_nodes([], nodes, _opts), do: nodes

  defp attach_nodes([var_node | tail], nodes, opts) do
    {_value, new_nodes} = attach_node(var_node, nodes, opts)
    attach_nodes(tail, new_nodes, opts)
  end

  defp attach_node(node, nodes, opts) do
    if :lists.keymember(node, @elem_node, nodes) do
      {:already_attached, nodes}
    else
      not_master = node != Node.self()

      startup =
        if not_master && !Keyword.get(opts, :no_start, false) do
          start_node(node, Keyword.get(opts, :start_args, ""))
        else
          {:ok, node}
        end

      case startup do
        {:ok, var_node} ->
          if !Keyword.get(opts, :no_stats, false) do
            if not_master do
              Node.monitor(var_node, true)
            end

            Node.spawn_link(var_node, __MODULE__, :statistic_collector, [])
          end

          _ =
            case Keyword.get(opts, :on_attach) do
              {m, f} when is_atom(m) and is_atom(f) ->
                Kernel.apply(m, f, [var_node])

              _ ->
                nil
            end

          {:attached, nodes ++ [{999_999, var_node}]}

        {:error, _} ->
          {:error_on_start, nodes}
      end
    end
  end

  defp start_node(node, args) do
    [namestr, host] =
      node
      |> Atom.to_string()
      |> String.split("@")

    name = String.to_atom(namestr)

    case :slave.start(host, name, args) do
      {:ok, var_node} ->
        {:ok, var_node}

      {:error, {:already_running, var_node}} ->
        {:ok, var_node}

      {:error, reason} ->
        {:error, reason}
    end
  end

  defp pop_node(nodes, excluding) do
    case excluding do
      [] ->
        [{load, n} | tail] = nodes
        {n, tail ++ [{load + 1, n}]}

      _ ->
        case :lists.search(
               fn {_load, var_node} -> !:lists.member(var_node, excluding) end,
               nodes
             ) do
          false ->
            {nil, nodes}

          {:value, {load, n}} ->
            rest = :lists.keydelete(n, @elem_node, nodes)
            {n, rest ++ [{load + 1, n}]}
        end
    end
  end

  defp get_elements(_pos, []) do
    []
  end

  defp get_elements(pos, [e | t]) do
    [:erlang.element(pos, e) | get_elements(pos, t)]
  end

  defp stop_em([]) do
    :stopped
  end

  defp stop_em([n | tail]) do
    :rpc.cast(n, :erlang, :halt, [])
    stop_em(tail)
  end

  @spec do_spawn(pid(), module(), atom(), list(term())) :: term()
  def do_spawn(gl, m, f, a) do
    :erlang.group_leader(gl, self())
    apply(m, f, a)
  end

  defp insert_node({load, var_node}, [{l, var_node} | tail]) when load > l do
    pure_insert({load, var_node}, tail)
  end

  defp insert_node({load, var_node}, [{l, n} | tail]) when load <= l do
    t = :lists.keydelete(var_node, @elem_node, [{l, n} | tail])
    [{load, var_node} | t]
  end

  defp insert_node(ln, [h | t]) do
    [h | insert_node(ln, t)]
  end

  defp insert_node(x, []) do
    _ = IO.puts("Pool_master: Bad node list #{inspect(x)}")

    :erlang.exit(:crash)
  end

  defp pure_insert({load, var_node}, []) do
    [{load, var_node}]
  end

  defp pure_insert({load, var_node}, [{l, n} | tail]) when load < l do
    [{load, var_node}, {l, n} | tail]
  end

  defp pure_insert(l, [h | t]) do
    [h | pure_insert(l, t)]
  end

  def statistic_collector() do
    statistic_collector(5)
  end

  defp statistic_collector(0) do
    :erlang.exit(:normal)
  end

  defp statistic_collector(i) do
    :timer.sleep(300)

    case(:global.whereis_name(@server_name)) do
      :undefined ->
        statistic_collector(i - 1)

      m ->
        stat_loop(m, 999_999)
    end
  end

  defp stat_loop(m, old) do
    :timer.sleep(2000)

    case(:erlang.statistics(:run_queue)) do
      ^old ->
        stat_loop(m, old)

      new_load ->
        send(m, {Node.self(), :load, new_load})
        stat_loop(m, new_load)
    end
  end
end
